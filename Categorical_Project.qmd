---
title: "Untitled"
format: html
server: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(plotly)
library(tidyverse)
library(shiny)
source("CodeSpace.R")
```

# Introduction
Artificial neural networks have been developed to solve some of the typical problems that we can find in categorical analysis. For example, one can apply a logistic regression model to a binary data, but can also use neural network as a non-parametric model to achieve similar result. 

We aim to understand how the neural network works and to implement it on simulated data. We then compare the result with the one generated by the logistic regression model. At the end we might be able to answer if NN can outperform logistic regression in this classical example.

```{r}
#| panel: sidebar
textInput("vector_input", "Enter vector (comma-separated):", "2,3,1")
```

```{r}
#| panel: fill
plotlyOutput("plot1")
```

```{r}
#| context: server
selectedData<-reactive({
  inputs <- trimws(gsub("\\s", "", input$vector_input))
  as.numeric(strsplit(inputs, ",")[[1]])})

output$plot1 <- renderPlotly({
  inputs<-selectedData()
  
  layers<-lapply(inputs, function(x){seq(1:x)})
  
  for(i in 1:(length(layers)-1)){
    if(length(layers[[i+1]])==length(layers[[i]])){
      layers[[i+1]]<-layers[[i]]
    }
    else if(length(layers[[i+1]])>length(layers[[i]])){
      dis<-(max(layers[[i]])-min(layers[[i]]))/length(layers[[i]])
      original_vector <- layers[[i]]
      range_original <- c(min(original_vector)-dis, max(original_vector)+dis)
      layers[[i+1]] <- seq(range_original[1], range_original[2], length.out = length(layers[[i+1]]))
    }
    else if(length(layers[[i+1]])<length(layers[[i]])){
      dis<-(max(layers[[i]])-min(layers[[i]]))/length(layers[[i]])
      original_vector <- layers[[i]]
      range_original <- c(min(original_vector)+dis, max(original_vector)-dis)
      layers[[i+1]] <- seq(range_original[1], range_original[2], length.out = length(layers[[i+1]]))
    }
  }
  
  Neurons<-lapply(seq_along(layers), function(ind){matrix(c(rep(ind*10, length(layers[[ind]])), rep(1, length(layers[[ind]])), layers[[ind]]), ncol = 3)})
  Neurons<-map(Neurons, function(x){rbind(x, matrix(c(x[,1], rep(2, nrow(x)), x[,3]), ncol = 3))})
  Neurons<-map(Neurons, function(x){rbind(x, matrix(c(x[,1], rep(0, nrow(x)), x[,3]), ncol = 3))})
  
  dots<-do.call(rbind, Neurons)%>%data.frame()
  
  colnames(dots)<-c("X", "Y", "Z")
  
  # Create a 3D plot with dots and a line
  p<-dots%>%plot_ly()%>%
    add_trace(
      type = "scatter3d",
      mode = "markers",
      x = ~X,
      y = ~Y,
      z = ~Z,
      marker = list(size = 6, color = "#87CEFA", symbol = "cube")
    ) 
  
  vertices<-list()
  for(i in 1:(length(Neurons)-1)){
    for(j in 1:nrow(Neurons[[i]])){
      for(k in 1:nrow(Neurons[[i+1]])){
        vertices<-c(vertices, list(rbind(Neurons[[i]][j,], Neurons[[i+1]][k,])))
      }
    }
  }
  
  vertices<-map(vertices, function(x){df<-as.data.frame(x); colnames(df)<-c("X","Y","Z"); return(df)})
  
  for(i in 1:length(vertices)){
    p<-p%>%add_trace(
      type = "scatter3d",
      mode = "lines",
      x = vertices[[i]]$X,
      y = vertices[[i]]$Y,
      z = vertices[[i]]$Z,
      line = list(color = "#696969", width = 1)
    )
  }
  
  p<-p%>%layout(
    showlegend=FALSE,
    scene = list(aspectmode = "manual", aspectratio = list(x = 3, y = 1, z = 1),
                 xaxis = list(showgrid = FALSE, tickvals = NULL, zeroline = FALSE),
                 yaxis = list(showgrid = FALSE, tickvals = NULL, zeroline = FALSE),
                 zaxis = list(showgrid = FALSE, tickvals = NULL, zeroline = FALSE)),
    plot_bgcolor = "#232323",
    paper_bgcolor = "#232323")
  p
})
```

```{r}
circulo <- function(x, R, centroX=0, centroY=0){
r = R * sqrt(runif(x))
theta = runif(x) * 2 * pi
x1 = centroX + r * cos(theta)
x2 = centroY + r * sin(theta)

z = data.frame(x1 = x1, x2 = x2)
return(z)
}

datos1 <- circulo(500,0.5)
datos2 <- circulo(500,1.5)
datos1$y <- 1
datos2$y <- 0
datos <- rbind(datos1,datos2)
rm(datos1,datos2, circulo)
rws<-sample(1:nrow(datos))
datos <-datos[rws,]
head(datos)

ggplot(datos,aes(x1,x2, col = as.factor(y))) + geom_point()
```

```{r}
test<-NeuralNet$new(data=datos[1:800,], hidden_neurons=40, num_iteration=50000, learning_rate=0.95)
plot(test$output$cost_hist)
```

```{r}
y_pred<-test$makePrediction(testdata=datos[201:1000,], 40)

df_pred<-data.frame(x1=datos[201:1000,"x1"], x2=datos[201:1000,"x2"], y_pred=as.numeric(y_pred), y_true=datos[201:1000,"y"])%>%
  gather("Type", "Val", 3:4)

ggplot(df_pred, aes(x1, x2, col=as.factor(Val))) +
        geom_point() +
        facet_wrap(~Type,scales = 'free',labeller = label_parsed) + theme_bw() +
        labs(x = "X1",
             y = "X2")
```

